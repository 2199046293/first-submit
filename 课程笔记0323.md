# 前锋教育-鸿蒙-2401笔记

## day0323

### 基本认识html

1. title这个是标签
2. ctr+?表示注释，或者取消注释，shift+!+回车表示html的基本格式
3. html:超文本标记语
4. body表示具体页面显示内容
5. 单标记：
   含义：只有一个<>，<标签名字 属性=“属性值"" 属性="属性值">，没有结束
6. 双标记：
   含义：有两个<标签名字 属性="属性值" 属性="属性值">`</标签名字>`
7. 属性：比如：身高，体重
8. 属性值：比如：165cm，92斤

### 文本修饰

#### 文本修饰的标记(font)

   大小，颜色，字体，加粗，下划线等 	基本语法：`<font></font> 属于双标记`
   快捷键：font+tab / font+回车

#### 快捷键tab

10. shift+tab按键,选中你选中的几行，可以实现几
    行内容同时往前，反之，tab是同时往后。

#### font的字体属性，大小属性，颜色属性

12. 单纯使用font标签不能修饰，需要有属性值才能修饰
    字体属性：face:"对应的字体：宋体，隶书，楷体等"
    size:1最小，7最大
    color:blue等

#### font的加粗，倾斜，下划线的语法：

13. 加粗：
    对文本实现加粗效果
    属于双标记
    基本语法：`<b> 文本</b>或者<strong>文本</strong>`
    快捷键：b+tab按键 strong加tab按键 或者 b+回车 strong加回车
14. 倾斜：
    对文本实现倾斜效果
    属于双标签
    基本语法：`<i>文本</i> <em>文本</em> <var>文本</var>`
    快捷按键：i+回车.....同理
15. 下划线标签：
    基本语法：`<u>文本</u> 或者<ins>文本</ins>`
    一般用u的多

#### 嵌套标签：

16. 嵌套标签：
    基本语法：`<u><i>文本</i></u>`

## day0324

### 删除线：

    `<s></s>或者<del></del>`

### 标签：（角标，标记，标题，空，有序列表，无序列表，段落，自定义列表标签，盒子标签，其中，有序，无序，盒子段落，标题标签是区分语句块的标签）

18. 角标标签：
    比如m2,m3,h2o  基本语法：`<sup>数值</sup>(上角标)，<sub>数值</sub>(下角标)`
19. 标记标签：注解补充：lorem*数值,生成数值次虚拟文本
    含义：给文本背景高亮颜色，跟荧光笔勾画文字一样
    基本语法:`<mark></mark>`
    空标签：基本语法：`<span></span>独立修饰文本，都是横向展示的。没啥含义。`
20. h1最大，h6最大。标题划分。`<hn>文本</hn>独占一整行，自带加粗，自带换行。`
    应用场景：h1是大标题，文章标题，，新闻标题，等。
    h2是副标题
    h3是小标题
    h4到h6视情况而定。
21. 有序列表标签：
    基本语法：`<ol>    <li>文本</li>  <li>文本</li>   </ol>`
    ol只允许放置li，如果要嵌套别的，只允许在li中嵌套。ol中的属性：type:A/a 或者/I/i或者/1
    start=“数值"表示从第几个字母或数字开始。
22. 无序列表标签：
    基本语法：`<ul>    <li>文本</li> <li>文本</li>   </ul> `
    ul中的属性：type:""disc==黑色实心原点，circle==空心圆，square=正方形，none==取消列表栏
    ul里面只能嵌套li,非要嵌套，要放在li中
23. 自定义列表标签：
    基本语法：`<dl>  <dt>问题/图片</dt>  <dd>问答/图片</dd>   </dl>`
    dd存在一个缩进的情况（在网页中），一般里面放一组dt和dd就可以了。
24. div元素/盒子元素			只要有这个，可以做好多种状态的模态框，弹窗等，在App/车载系统中的中控布局样式									基本语法：`<div>文本/图片/其他区块/文本修饰类型标记</div>															作用：区块划分`
    特点：默认是纵向展示
25. 段落标签：一般用在文本修饰
    基本语法：`<p>文本/文本修饰</p>`
    p标签里面只能放置文本/图片/其他文本修饰标记，别的区块划分，和他自己本身都不能嵌套,p标签不嵌套其他标签

### 水平线

26. 水平线：特点：默认存在阴影效果；默认宽度独占一整行。基本属性：width="300px"(默认出现在中间位置),调整水平属性：align="left/right/center"，左侧对齐，居中对齐，右侧对齐。noshade="noshade",取消阴影效果。设置阴影颜色：color="颜色取值"。设置高度：size
    基本语法：`<hr>单标签。`

### 折行标签：

27. 折行标签：`<br>普通的文本默认都是横向显示的，div是纵向显示的，<br>也可以将文本换成纵向显示。`

### 图片，超链接，锚点，空格效果

28. 图片：
    基本语法：`<img src="路径">html和图片同一个文件夹，路径直接使用图片名字即可，如果不同文件夹，../返回上一级`
    可以使用相对路径和绝对路径
    alt=”图片描述“，用在图片破损的时候，不破损的时候不显示描述。占位置。
    title="图片提示信息"，放在图片上会显示，不占位置																					title和alt在实际开发中,都填上，可以方便爬虫网站数据，提高搜索引擎搜索的排名
    height="高度"
    width="宽度"
    在实际开发中，只需要填高度和宽度中的一个即可，防止图片挤压或变形。
29. 超链接：
    基本语法：
    `<a href=""></a>	默认特点是自带下横线，颜色是蓝色的，访问过后，会变成紫色。#表示空链接`
    超链接锚点功能：
    实现相同页面不同区域的跳转。使用场景：返回置顶，楼梯层，通讯录。
    基本语法：
    点击区域：`<a href="#锚点名字">文本</a>`
    跳转区域：`<div id="锚点名字">文本</div>`
30. 实现空格效果：
    &nbsp；半角空格
    &emsp是全角空格

## day0325

### 后代选择器，子代选择器，群组选择器，选择器的权重，优先级

1.后代选择器：

当前元素内，符合条件的所有元素，不限于子元素和孙子元素的元素

基本语法：

选择器1 选择器2{}

2.子代选择器：

当前元素的所有子元素

基本语法：

选择器1>选择器2{}

3.群组选择器：

作用：用来节省代码空间的，把公共代码部分进行提取，达到节省的效果

基本语法：

选择器1，选择器2，选择器3{}

4.选择器的权重：

id(100)>class(10)>标签(1)>通配符(0)

不同选择器的有优先级和先后顺序无关，和权重值有关。当涉及到子代和后代选择器时，一般权重值要叠加，class是10，标签是1，但当叠加值为10层，始终遵循id>class>标签>通配符

通配符*

### css中的文本字体规格等，font-size等

5.文本规格：（css的内容）

导入css的三种形式：link形式，在head中加入 `<style>css的内容</style>，行内。其中，行内大于行间大于link.看的是先后顺序`

a.文本的大小：

属性：font-size

取值：数值加px   /数值加em   /数值加rem

总结：默认字体大小为16px

之前的浏览器默认显示最小字体为12px，最新的可以小于12px.

b.文本的字体：

属性：font-family(字体族科，字体加粗)

属性值：可以为英文，可以为中文字体。

特点：

属性后面可以加多个字体，多个字体之间用逗号连接

中文字体不用带引号，英文字体如果是多个英文单词，需要加引号。

c.颜色：

color:red，black，等

#某某某（可用qq截图查看）等

rgb:(某某某)等

三种样式颜色表达形式

## day0326

### css中的文本修饰，font-weight等

d.文本加粗

属性：font-weight

取值：数值型：

100到900的整百的数值

100==细体

400==正常字体

700==加粗字体

900==更粗字体（更具强调性）

关键词类型：

lighter==细体

normal==正常体

bold==加粗

bolder==更粗字体（更具强调性）

问题：为啥有了b/strong ,还要学css

实际开发中，我们比较喜欢使用css完成，方便维护；能简化页面结构；能支持做一些简单交互效果。

问题2：为啥默认字体没有加粗，没有细体，我们还要使用400和normal:

有些内容会自带加粗效果。

e.文本倾斜：

属性：font-style

取值：italic==倾斜

oblique==斜体字（更加具有强调性）

normal==正常字体

f.文本的修饰线：

为文本添加一条或者多条修饰线（下划线，删除线，上划线，等）

属性：text-decoration:

color,style,line

注意：text-decoration后面加多个属性值，是复合属性

单一属性：

修饰线的位置：下划线，上划线，中间线

text-decoration-line:underline(下划线)，line-through(中划线)，overline(上划线)，none(取消修饰线)

修饰线的颜色：

text-decoration-color:red;

修饰线的样式：

text-decoration-style:

solid:单实线

double:双实线

dashed：虚线（线段状）

dotted：虚线（点状）

wavy:波浪线

g.文本的首行缩进：

属性：text-indent:数值+px  / 数值+em

h.文本大小写转换：

属性：text-transform

取值：

uppercase:===全部大写

lowercase;===全部小写

capitalize==全部英文首字母大写

小型大写：font-variant:small-caps;

i:

文本水平对齐：

属性：text-align

取值：left；左对齐

right：右对齐

center:居中对齐

justify 两端对齐

text-align-last（单独最后一行的对齐方式）：left,center,right,justify(放在只有一行的情况下的居多，单行文本一般不直接使用text-align)

单行文本垂直对齐:

line-height 行高，距离顶端的距离，单位是px

注意在实际开发中：不要超过实在的行高。

文本的修饰文本的规则

    1)font-size

    2)font-family(字体)

    3)color

    4)font-weight（粗细）

    5)font-style

    6)text-decoration（文本修饰线）

    7)text-align（文本对齐方式）

    8)text-last-align

    9)line-height

    10)text-indent（首行缩进）

    11)text-transform

    12)font-variant（

font-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。）

### 说明

## day0327

### 字符与字符间距

字符间距：英文字母，标点符号，空格等特殊符号之间的距离，称之为字符间距

属性：letter-spacing

取值：数值加px

### 单词与单词间距：

词间距：英文单词与英文单词之间的距离

属性：word-spacing

(注意练习:间距.html)

### 背景规则：

1.背景颜色：

属性：background-color

取值：颜色单词/#六位十六进制颜色/rgb/rgba（red,green,blue,alpha)

alpha==颜色通道，控制这个颜色的透明度(取值在0到1，0代表白色。1表示不透明，取值保留一位小数，小数可以省略0）

(注意联系：背景颜色.html)

应用场景：特殊透明效果，弹窗等

2.背景的重复：（平铺）、

属性：background-repeat

取值：repeat==平铺（并且默认情况下是平铺的）

no-repeat==不平铺

repeat-x==水平平铺

repeat-y==垂直平铺

（注意练习：背景平铺.html)

3.取消平铺之后，图片默认再哪里显示呢？

默认在元素的左上角位置开始显示

属性：background-position

取值：

a.关键词：x=left/right/center

y=top/bottom/center

b.数值：数值+px

(注意练习：背景平铺.html)

4.背景图片尺寸大小：

属性：background-size：x   y

注意：一般不用数值改变图片大小，会让图片变形

取值：

(1)关键词：

cover:覆盖，铺满全部区域，等比例放大图片，，直到完全覆盖边框（容易显示不全）

contain:等比例放大图片，直到有一个边铺满了就结束（容易留白）

实际开发中，使用cover的多。

(2)数值：x  y(单位：px)

5.背景的固定/滚动

固定：当滚动浏览器时候，我们的图片不会随着滚动条的滚动而向上滚动

滚动：当滚动浏览器的时候，图片会因为滚动条的滚动而向上滚动

属性：background-attachment

取值：fixed /scroll

6.背景图片：

属性：

background-image:url()

7.复合背景属性：

background:color image repeat position/size attachment

注意：

复合属性后面，多个属性可以换位置，但是position和size不能换位置

如果只有位置调整，可以省略size

如果只有大小，没有位置，则位置必须携带，取值设置为0px 0px；

## day0328

任何一个案例，必须添加

*{

margin:0;padding:0

}

用来改变文本与文本之间的距离，让其紧紧的贴在一起

### 列表修饰和知乎案例

1.知乎案例（注意练习）

2.列表修饰：

实际开发中使用无序列表

a.列表项目符号：
list-style-type:
disc
circle
square
none
list-style-image:url(路径)

<!-- 一般不使用，因为不方便调图片大小 -->

list-style-position:
inside;outside;(注意练习：列表的位置.html)(一个前面一点，一个后面一点)

列表属性：
list-style-type;list-style-position;list-style-image;
复合属性：
list-style:type image position
实际开发中，一般使用list-style:none

### 面试题：

在鸿蒙生态开发中，有一些css具有继承性，既能够放在父元素上实现效果，也可以在子元素中实现效果。
有哪些属性具有继承性：
a.文本属性具有继承性：
font-size;font-weight;letter-spacing/word-spacing
b.列表属性：
list-style-type,list-style-position,list-style-image

### 边框

含义:值得是一个容器,盒子,的边缘;所有的内容应该是在这个边缘连显示

    属性:border   一个属性后面跟好几个取值,就是一个复合属性

    取值:10px solid gray

    10px======边框的粗细=====border-width

    solid=====边框的样式=====border-style

    gray======边框的颜色=====border-color

    1)样式的取值有哪些:border-style;

    solid;===单实线

    double;==双实线

    dashed;==虚线(线段)

    dotted;==虚线(点状)

    可以了解到一个知识点:背景颜色会蔓延到边框为止结束

    2)单一属性能不能直接独立使用

    如果单独使用单一属性的话,只有单独使用边框样式(border-style)的时候才会实现效果,默认会出现一条3px粗细黑色的边框

    边框样式是必须值;

    3)如果使用边框border,一下实现四个方向,border-width:value;三个单一属性使用的时候,跟一个值,也是实现了四个方向

    研究:border-width/style/color:取值问题

    border-width:v1;========实现四个方向的粗细

    border-width:v1 v2;=====实现四个方向;v1:上下;v2:左右;

    border-width:v1 v2 v3;==实现四个方向;v1:上;v2:左右;v3:下

    border-width:v1 v2 v3 v4实现四个方向;v1:上;v2:右;v3:下;v4:左

    注意的是:取1-取4 一下子实现的是一圈的边框, 尤其是取四个值得时候:顺时针旋转的规则:上右下左

    4)无论取值为一个值还是多个值,一下子实现四个方向:有没有办法只修饰一个方向呢

    单一方向的属性:

    border-方向词:10px solid gray

    border-top:

    border-right:

    border-bottom:

    border-left:

    边框补角的原理大家已经知道了,因为浏览器的渲染机制的问题会把相邻交的区域给不全,并且进行对角线平分补色;

    -->

含义:值得是一个容器,盒子,的边缘;所有的内容应该是在这个边缘连显示

    属性:border   一个属性后面跟好几个取值,就是一个复合属性

    取值:10px solid gray

    10px======边框的粗细=====border-width

    solid=====边框的样式=====border-style

    gray======边框的颜色=====border-color

    1)样式的取值有哪些:border-style;

    solid;===单实线

    double;==双实线

    dashed;==虚线(线段)

    dotted;==虚线(点状)

    可以了解到一个知识点:背景颜色会蔓延到边框为止结束

    2)单一属性能不能直接独立使用

    如果单独使用单一属性的话,只有单独使用边框样式(border-style)的时候才会实现效果,默认会出现一条3px粗细黑色的边框

    边框样式是必须值;

    3)如果使用边框border,一下实现四个方向,border-width:value;三个单一属性使用的时候,跟一个值,也是实现了四个方向

    研究:border-width/style/color:取值问题

    border-width:v1;========实现四个方向的粗细

    border-width:v1 v2;=====实现四个方向;v1:上下;v2:左右;

    border-width:v1 v2 v3;==实现四个方向;v1:上;v2:左右;v3:下

    border-width:v1 v2 v3 v4实现四个方向;v1:上;v2:右;v3:下;v4:左

    注意的是:取1-取4 一下子实现的是一圈的边框, 尤其是取四个值得时候:顺时针旋转的规则:上右下左

    4)无论取值为一个值还是多个值,一下子实现四个方向:有没有办法只修饰一个方向呢

    单一方向的属性:

    border-方向词:10px solid gray

    border-top:

    border-right:

    border-bottom:

    border-left:

    边框补角的原理大家已经知道了,因为浏览器的渲染机制的问题会把相邻交的区域给不全,并且进行对角线平分补色;

    -->

### 浮动：（不太清楚）

    含义:让原本纵向显示的元素,横向显示,让元素漂浮起来

    属性:float

    取值:none/left/right

    none;===不浮动,默认值

    left;===左侧浮动

    right;==右侧浮动

    特点1:只要添加浮动,不占页面空间,后面元素会上去补位置;

    特点2:浮动元素,只会再本行中左右浮动

    特点3:都给子元素添加浮动,这些元素会横向排列,

    取值为left;左侧浮动,元素会从左向右依次排列

    取值为right;右侧浮动,元素会从右向左依次排列

    总结:只要你想他们都横向显示,需要添加浮动即可完成

    特点4:如果剩余空间不够的情况下,元素会折行显示

    补位元素,容易出现被卡主的效果,折行元素参照位置是前面一个元素右侧和下面剩余空间的是多少进行补位的

    如果我们再设置的时候没有给父元素添加一个高度的话,这种情况被称之为高度的自适应

    如果在自适应的情况下,给子元素添浮动的话,父元素的高度会随之降低,这种效果倍称之为高度塌陷;

    如何解决这个高度塌陷呢?

    1)直接方法:设置一个高度

### 内边距

> 内边距
>
> 1)内边距
>
> 含义:内容和边框之间的距离,边框里面的距离; 例如:衣服和肉之间的距离
>
> 属性:padding;
>
> 取值:
>
> padding:v1;========实现四个方向
>
> padding:v1 v2;=====实现四个方向:v1:上下;v2:左右
>
> padding:v1 v2 v3;==实现四个方向:v1上,v2左右,v3下
>
> padding:v1 v2 v3 v4实现四个方向:v1上,v2右,v3下,v4左
>
> 无论取值为一个值还是四个值,一下子能实现一圈方向,取值为四个值的时候,顺时针方向记忆:上右下左
>
> 有没有办法只实现一个方向的内边距?
>
> 使用方法:
>
> padding-方向词
>
> padding-top:上内边距
>
> padding-right:右内边距
>
> padding-bottom:下内边距
>
> padding-left:左内边距

### 外边距

> 外边距：
>
> 含义:边框与边框之间的距离,边框外边距距离; 例如:衣服和衣服之间的距离
>
> 属性:margin:
>
> 取值:
>
> margin:v1;=========实现四个方向
>
> margin:v1 v2;======实现四个方向:v1:上下;v2:左右;
>
> margin:v1 v2 v3;===实现四个方向:v1上,v2左右,v3:下
>
> margin:v1 v2 v3 v4;实现四个方向:v1上,v2右,v3:下,v4左
>
> 无论你取一个值还是4个值,一下子能实现一圈的间距,如果取值为四个值的时候,还遵循的是顺时针方向:上右下左;
>
> 能不能只设置一个方向的外边距?
>
> 可以设置:
>
> 属性:margin-方向词:
>
> margin-top:
>
> margin-right:
>
> margin-bottom:
>
> margin-left:

### css的补充内容，三种形式

    1.复习
        文本修饰类型
            1)加粗
            2)倾斜
            3)下划线
            3)删除线
            5)角标
            6)文本修饰:font
            7)空标记:span
            8)标记标签:mark
        区块划分类型
            1)标题
            2)列表
            3)盒子
            4)段落

    其他类型
            1)水平线:hr
            2)文本折行:br
            3)图片:img
                alt和title之间的区别?
                    1)相同点
                    2)不同点
            4)超链接:a
                1)超链接页面跳转(超链接)
                2)相同页面不同区域跳转(锚点)

    2.讲解今天的内容
        今天要讲解的主要内容:
            1)CSS的内容
                HTML
                CSS
                JS
                TS
                arkTS
            2)CSS的含义是什么作用是什么?
                CSS本质含义:cascanding(层叠) style(样式) sheet(表) 严格意义上面被称之为:层叠样式表
                本质作用:对页面结构的一个修饰
                为啥要学习CSS呢? 可以简化很多结构
            3)如何简化的?
                实现一个效果:文本;加粗,倾斜,下划线,颜色,大小,字体

    4)学习CSS的相关内容了
                CSS的基本语法:
                    选择器{属性:属性值;属性:属性值;属性:属性值;}

    选择器:查找页面元素的方式方法,这种方法有很多  (勇哥:李勇,李纪,铁牛哥哥,二狗子,狗剩)
                    {}:对选择器查找到的元素进行修饰的,让对应的元素实现对应的样式
                    勇哥{
                        发型:麻花辫;
                        T恤:蓝色;
                        裤子:牛仔裤;
                        鞋子:豆豆鞋;
                    }
                    男生{

    }
                    女生{

    }
                面试题:力扣:===多选题
                    1)HarmonyOS生态开发CSS语言中,CSS基本语法有几个部分组成?
                            2个部分:选择器和{}(样式规则)
                    2)HarmonyOS生态开发CSS语言中,CSS样式规则有几个部分组成?
                            2个部分:属性和属性值
                    总结:CSS中语法特点
                        属性和属性值使用冒号链接
                        每一组属性和属性值结束后需要使用分号
                        最后一组属性和属性值,后面的分号可以带可以不带;推荐你带上;

    5)语法的使用:
                CSS的基本语法:
                    选择器{属性:属性值;属性:属性值;属性:属性值;}

    CSS的使用位置其实有很多:
                a)行内使用位置==行内样式
                    使用要求如下:
                        含义:把对应的CSS基本语法放在标签里面直接使用
                        语法:`<div style="属性:属性值;属性:属性值;">`文本 `</div>`
                        特点:
                            使用再行内的时候,标签就是选择器 style代表的是样式规则;
                        行内位置能实现:但是他有弊端:
                            1)代码比较冗余重复率较高,复用性不好
                            2)如果你使用行内样式,后期不易维护
                            3)没有做到开发标准:结构和样式的分离

    也有一点点的优点:
                            快速高效对一个标签修饰

    b)内部使用位置==内部样式
                    使用要求如下:
                        含义:把对应的CSS代码放在一个独立的style标签里面,并且这个标签,放在head里面
                        语法:`<head>`
                                `<style>`
                                    选择器{样式规则}
                                `</style>`
                            `</head>`
                            h1{background-color:red;color:blue}
                            //意思:页面中谁叫h1,就匹配到谁,对他们进行修饰; 对页面中的h1进行修饰
                        优缺点:
                            内部样式有哪些优点
                                1)做到了结构和样式的分离;让结构更加简洁
                                2)代码复用性高,解决了冗余的问题
                            内部样式有哪些缺点
                                1)如果代码过多的话,容易造成头重脚轻
                                2)代码过多的话,需要来回滚动屏幕,操作比较麻烦
                                3)存在一个精确度的问题

    c)外部使用位置==外部样式
                    使用要求如下:
                        含义:把对应CSS语法内容,放在一个独立的以.css为后缀名的文件中,通过引入的形式把样式引入进来
                        基本语法:
                            01.css
                            02.html  需要再html页面文件中,通过link标签进行引入`<link rel="stylesheet" href="路径">`
                        link引入的文件,
                            完全的实现了结构样式的分离;实际开发的时候,必须遵循

    6)CSS基本语法使用位置哪一种方法都可以实现效果
                    问题:如果三个样式一起修饰该实现是谁?
                    晓迪,周涛,子瑞====三个样式

    勇哥===对勇哥进行修饰
                标准的问题:多个样式表一起修饰的时候,谁的级别高,样式(表)的优先级：
                !important>行内>内部>外部

    7)详细的介绍学习语法了
                选择器{属性:属性值;属性:属性值}
                学习的重点:选择器
                含义:查找页面元素的方式方法;
                a)标签选择器
                    含义:通过标签名字查找页面的元素;
                    基本语法: p{} div{} h1{} span{}
                b)class类型选择器
                    含义:通过给元素起一个class类名,别名,通过这个别名找页面元素
                    基本语法:
                        起名:`<div class="box"></div>`
                        查找: .box{样式规则}
                    注意:
                        类名查找的时候, .不能省略
                c)ID选择器
                    含义:通过给元素起一个id名字,别名,通过这个id名字查找元素
                    基本语法:
                        起名:`<div id="hipop"></div>`
                        查找: #hipop{样式规则}
                    注意:
                        id查找的时候, #不能省略

    起名字的命名规范
                    1)不能使用汉字,不能使用特殊符号
                    2)不能以特殊符号开头,推荐使用小写字母开头
                    3)可以使用字母,数字,下划线,连接符一配合使用可不能以数字开头
                    4)推荐使用见名知意的命名规则 header footer main box1 main1 main_1
                    5)可以使用驼峰命名法
                        名字由多个单词组成,从第二个单词开始起,首字母大写
                        gouwuche == gouWuChe
                        shopCar
                        detail
                    6)id具有唯一性

    d)通配符选择器
                    含义:用来匹配页面所有元素/某一个区域中的所有元素
                    用途:用来取消页面元素自带的间距;
                    基本语法: *{margin:0;padding:0}

    e)后代选择器
                    含义:当前元素内,所有符合条件的元素,不限于子元素或者是孙子辈分的元素
                    基本语法: 选择器1 选择器2{}
                f)子代选择器
                    含义:当前元素内,所有符合条件的儿子辈分的元素
                    基本语法: 选择器1>选择器2{}
                问题:后代选择器一定比子代选择器匹配的数量多?
                    要么是相等,要么是大于
                g)群组选择器
                    含义:用来节约我们代码的,能把公共的代码部分进行提取,起到节约代码的作用
                    基本语法: 选择器1,选择器2,选择器3{}

    如何查找元素:div里面的p`<div class="box">`
                        `<p class="p1">`你好 `</p>`
                    `</div>`
                    `<p>`文本 `</p>`

    .p1{}
                    div p{}
                    div>p{}
                    .box .p1{}
                    .box>.p1{}
                    div>.p1{}
                    div .p1{}
                    .box>p{}
                    .box p{}

    8)今天的学习流程
                1)CSS的优势
                2)CSS基本语法 : 选择器{}
                3)基本语法的使用位置 : 行内,内部,外部
                4)推到出来, 经常使用外部
                5)样式一起使用的时候,实现谁的效果 : 优先级
                6)选择器的知识点 : 标签,类,id,通配符,群组,后代,子代
                7)接下来学习的内容 :不同的选择器修饰同一个元素的时候,实现哪一种样式
                8)选择器权重值
                9){}样式规则里面的内容

    9)选择器的权重值
                标签:(p)
                类:(.)
                id:(#)
                通配符:(*) 他的权重值是最低的,0000(0)

    标签和类 : 类 > 标签
                类和ID  : id > 类
                标签和ID : id > 标签

    综上:
                    小结论:不同的选择器修饰同一个元素的时候,与代码顺序没有关系,跟选择器的权重值有关系
                    小结论: 权重(id>类>标签>通配符)
                    id(0100,100)>类(0010,10)>标签(0001,1)>通配符(0000,0)
                    这些值是一个虚拟的数值,主要是方便你记忆的;

    会使用到对应的后代和子代选择器;会出现权重值相加的问题
                权重值相加有一个特殊情况:

    10)样式规则相关内容{}
                含义:用来规定选择器查找到的元素实现何种样式的
                种类:样式规则种类有很多规则;
                    a)文本规则:对文本,对文字的修饰
                    b)背景规则:背景颜色,图片,位置等等
                    c)列表规则:对有序和无序列表的修饰
                    d)盒子模型规则:调整距离
                    e)边框规则:对边框边缘的修饰
                    f)浮动规则:(*)
                    g)弹性盒子规则:
                    h)溢出规则:....
                学习一部分属性和属性值

### ps的一些内容：（不太清楚）

1.ps===pscook
            只学习三个功能: 测量大小,吸取颜色,截取素材
            1)将素材(设计稿)直接拖拽到你的软件中(在线软件中)
            2)没有尺子的话,直接点击上面工具栏里面的视图===标尺
            3)再标尺上面右键可以更换单位,设置成px单位

    a)吸取颜色
                使用左侧图标里面的第六个:吸管工具(吸取颜色)
                点击左下角的色卡(前景色)==弹窗里面有对应的颜色设置
            b)测量大小
                使用左侧第二个图标:矩形选框工具
                    测量大小的时候:文本大小:文字的上面测量到文字的下面
                    可以把信息面板调整出来:窗口里面找到信息面板==存着你想要的信息
            c)截取素材

### 鸿蒙开发中，Atic语言中的补充内容，让图形变得更好看的

.bordeRadius（数字）(让边框圆框)
Image($r('app.media.   '))图片本地路径，还有复制网站路径实现操作，详情见devsco中的test2中,注意练习：test2文件夹下。
实战：
做一个今日头条登录页，在dengluye文件夹下。注意练习。

### button属性，Text属性，TextInput属性，border下划线，margin,padding的详细运用见denluye文件夹。Image的插入在test1和test2文件夹下。

### 变量的知识

let表示不可以重复定义，可以修改
var 可以重复定义，可以修改
变量的定义和赋值
两种，一种不加类型，一种加类型：
let data=111

<!-- js类型 -->

let data:number=111
let margin:{ top:number;left:number}={top:10,left:20}
联合类型：
let data:string | number="111"
两者类型都可以。

<!-- ts类型 -->

彼岸:
文档选择器那个document.queryselector表示
从网页或者文档中选择css 选择器

彼岸:
今天讲了变量的命名，原始变量 Undefined表示只定义不赋值
花括号{}用来存放多个变量数组
也可以用来作为类型返回。
let data={属性：属性值，属性：属性值}

### arkts语言

arkts语言的变量升级后，定义变量改为：
@State 变量名：类型=内容

### 鸿蒙案例1

### 封装代码，if条件语句，三元条件（注意查看对应html这里面的内容进行总节），注意总结iphone计算器在那个软件中。（if判断语句）

alert 可以将内容直接在网页中显示，详情看上面大标题对应的内容

## day0407

### 数组在js,ts中的表达形式，详情请看，01定义仓库存放多个数据，类型限制，操作数组里面的数据，artks语言结合js,ts都可以使用。

### 循环

foreach，for循环，看这里面的循环例子。

### class类在鸿蒙中的用法：

class 类名{
    title：string
    fin:number
    constructor(title：string
    fin:number){
        this.title=title
        this.fin=fin
    }
}放在@entry上面，类放在开头，然后new 类名（）放在struct里面，可以比较整洁，当然也可以用其他形式的类型限制，比如：let arr：{名字：类型，名字：类型}={名字：数据，名字：数据}。

### 标准特殊对象

Array,Date,Math
let array=new Array();
let date=new Date();
Math可以直接运用。

### 标准普通对象：

new object()
object.keys,object.value(忘了是keys还是key,value也不清楚，问题不大，不太使用)
object.assign(对象1，对象2等),用来合并多个数据

### 在数组中的语法：arr（标准特殊对象：array）

arr.length/splice/unshift/shift/push/pop/includes/reverse==翻转
arr.splice(索引，个数)，用来删除n个数据后得到到的数组
arr.includes(数据)，判断是否有这个数据，bool和false
arr.unshift/push（数据），数组前面追加一个数据，数组后面追加一个数据。
arr.shift/pop(数据)，数组前面删除一个数据，数组后面删除一个数据。

### 标准特殊对象：date

let date=new Date();
date.getFullYear():年
date.getMonth():月
date.getDate():日
date.getHours():时
date.getMinute():分
date.getSeconds():秒

### 标准特殊对象：math

Math.ceil:向上取整
Math.floor
Math.round(数据)，四舍五入
Math.random()，0到1的随机数

### 操作字符串str

str.replaceAll/includes/split/length/toString
(跟数组差不多)
replaceAll(旧数据，新数据)
split(分隔符，没有就默认逗号)，作用是：字符串变数组，按照分隔符分开
当分隔符为空字符串，str.split(""),作用：把每个字符都分开变成数组。

### 万物皆对象；函数名必须要加括号（）

### 定时器：语法

唯一标识=setTimeout(()=>{},毫秒)
1000毫秒=1秒
只能使用一次，不是只能点击一次的意思，是点击只能实现一次的作用。且倒计时不可用setTimeout,因为他只会从10跳到9，就不会动了，简称延时计时器，用来点击一次，实现延迟多少秒得到结果的作用
clearTimeout(唯一标识)用来清除计时器
唯一标识在build同级定义
唯一标识=setInterval(()=>{}，毫秒)
可以使用多次，连续
clearInterval(唯一标识)

### 常见错误:column()在鸿蒙中不可少，在鸿蒙中必须加width('100%')

## day0409

### 面试题1：写出n种数组去重方案=》遍历判断

let arr=[1,2,3,2,3]
let newArr=[];
arr.forEach((item,i)=>{
    let isFind=newArr.includes(item);
    if(!isFind){
        newArr.push(item)
    }
});
方案2：  `<!-- //出现1次，表示的是keys,输出结果为1:1，2：1，3：1（结果打印出key) -->`
let arr=[1,2,3,2,3]
let obj-{};
arr.forEach((item,i)=>{
    if(obj[item]){

    }else{
        obj[item]=1;

    }
});
console.log(obj);
console.log(Object.keys(obj));

### 面试题2：字符统计

let arr="aabccd".split("")
let obj={};
arr.forEach((item,i)=>{
    if(obj[item]){
        obj[item]++;

    }
    else{
        obj[item]=1;
    }
});
console.log(obj);

### 疑问：{}和数组都可以使用.名字和[名字]吗，什么地方该用，什么地方不该用，不太清楚。？？？

### 翻转字符串（面试题）=>详情请看翻转字符串.html

let str="abcd";
console.log(str.split(""))
console.log(str.split("").reverse())
console.log(str.split("").reverse().join(""))

### 字符串同样也可以str[i];不只是数组可以这样，split将字符变成数组，join将数组变成字符串。详情同样见 翻转字符串.html.

### 面试题：随机颜色（见鸿蒙实例）

### 面试题：格式化时间（见格式化时间.html）注意：在replaceAll中，是字符，那么旧数据就必须加"" 不然要出错，一定注意***,注意getFullYear（）是函数，必须加（），同理，函数一定要加括号。

### 待办实例：见鸿蒙实例：代办实例主要复习循环和类型限制，利用class类，新知识点如下：

checkbox语法，onChange语法。

### 父传子组件：单向传数据。只允许父组件修改，子组件修改不了

@prop子组件接收。详情见鸿蒙实例：shouyeyemian

### export default 数据，传单个数据，export 数据，传多个数据必须加{}，如：importfrom 数据

### 组件共享：将@Prop变成@Link,this.变成$

Prop不支持对象，只有boolen/number/string这些类型可以支持。link支持对象，都可以支持。

### 后代组件实现数据共享：@Consume 名字：类型  @Provide 名字：类型=数据，支持类型跟link一样，都支持

祖先节点里面加 @Provide 名字：类型=数据，表示允许后代共享数据，
子节点中加@Consume 名字：类型，后代就可以接收到父组件的值然后实现共享，一个变，全都变

### item，循环中的组件与组件的调用（特殊），详情请见tttexst鸿蒙实例，注意里面我标注在开头的内容。@ObjectLink，详情也是在这个鸿蒙实例里面。一般用在foreach里面。因为item没有this.

最主要的原因是item是对象，不允许prop类型，但是用link,因为没有定义在build（）同级，所以不加this. 而link必须有this.变成$，所以不用link,同理，在循环中的i也不能用this.i,除非你先定义了在build同级里面，但是因为i不是对象，是number类型，所以可以用prop接收。详情见shouyeyemian实例。
先写@Observed class这个类，然后再@ObjectLink 后面接收的类型必须为类的名字。这是必须的，而且这个是双向传递的，一个变，都要变，一般用在类修饰里面。Item是对象，不能用prop。

### 自定义类型：type 名字=冗余数据，放在@component前面，然后后面的冗余数据就可以用名字变换，详情见shouyeyemian实例之Tabbar

### 疑问：？？？export 传多个数据，将内容放在build()同级还是哪里

### 疑问2：报错：@provide和@Consume没有实现双向数据传递，表现在勾选全选，全不选上，在那个实例里面

export let a:boolean=true

## day0413

### 页面路由

### 页面跳转，router.pushurl(),详情见shouyeyemian实例之Tabbar,基本步骤如下：

基本实现：1.点击底部导航栏，能实现页面跳转
基本思想：页面跳转的基本原理是：点导航栏，实际上打开另外一个入口文件，@Entry是入口文件
基本步骤：
1.在pages文件夹下建立一个入口文件，
2.在main/resources/base/profile下添加刚建立好的入口文件的路径，注意一定要用双引号，不能加单引号，详情内容也是shouyeyemian实例
3.在tabbar里面相应位置添加router.pushUrl({url:"路径"})   //跳转页面其实跳转的是入口父组件的路径

### 页面替换:router.replaceUrl()，这个表示直接跳转，不会有前面的内存，因此在aboutToDisappear中，要使用这个

### 页面返回：router.back()返回上一页面

### 页面传参：,注意：这个是要保存当前页面，可能会出现连续跳转的情况，但是如果要使用页面返回，就必须使用这个

### router.pushurl({url:'',

params:{
    a:1,
    b:2,
    c:3
}
}),然后再路径接收参数，
let params=router.getParams()
console.log(JSON.stringify((params)))

详情见shouyeyemian实例之Tabbar

### 跳出小窗口，美化页面的代码：

 router.showAlertBeforeBackPage({
            message:'确定返回？'
          })
          router.back()

### 随机整数的固定公式

random=(min:number,max:number)=>{
    return Math.floor(Math.random()*(max-min+1)+min)

  }
  实例见随机颜色实例
  random(a,b)是前闭后闭

### 数据存储

  1.定义一个仓库，形式如下：
  export let userInfoStorage=new LocalStorage({
  username:'',
  avatar:'',
})
export let cityStorage=new LocalStorage({
  cityId:0,
  cityname:''
})
2.在需要的地方存储对应的数据，形式如下：
userInfoStorage.set('username',this.username)
3.在需要的对应的数据里面加上，用来接收数据，形式如下：
 username:string=userInfoStorage.get('username')`
 4.按退出，将消除存储的数据：
 a.先清空当前页面数据，让页面显示为立即登录的页面
 this.username='',

 b.清空仓库的数据，
 userInfoStorage.set('username','')
 第二种形式之形式1：
 AppStorage是单例，所有ApI都是静态的
 有则改之，无则创建,基本语法：
 AppStorage.SetOrCreate('name','值'),放在最开头，这个容易数据丢失，所以选择形式2可以安全点。
 修改：
 AppStorage.Set('name',this.name)
 AppStorage.Get('name')

形式2：

存在数据会一直存在：

PersistentStorsge.PensistProp('token','后端获取的token值')，放最开头，切记数据持久化必须放在app入口文件才会生效，即pages下的index.ets文件

然后用AppStorage.Get('token'),用来接收数据

注意：双向绑定，也可以用这个获取，（不太清楚）
@StorageLink('token') token:string=''

 *详情的实例还没写呢，在day0307存储数据那几个内容里面，下次记得把那个实例打出来，增加一下印象。

### 霸道总裁，强制转换

 this.item as 0|1|2 可以将类型强制转换成0|1|2的类型，注意特点

### ts新增了哪些数据类型：（面试题）

 any任意类型，字面类型，联合类型，自定义类型
 类型断言 as
 type 自定义类型名称=类型，放在组件最前面。

## day0416

### 加入购物车

### watching监控？？？

### 网络请求

#### 发送请求,短信发送，百度搜索这个的笔记的具体内容在day0314和day0309里面。

1.创建网络请求对象httpRequest
 const httpRequest=http.createHttp()

2.发送请求 接口地址（服务器代码地址），请求方式(GET/POST),额外参数

httpRequest.request(
    '',
    {
        method:http.RequestMethod.POST
        extraData: {
                "参数名": 数据,
                "参数名": 数据,
              }
    }
)
.then((res:http.HttpResponse)=>{//res result是结果
              if(res.responseCode===200){
                console.log('qf',res.result)
                const serverDate=JSON.parse(res.result as string)
                console.log('qf',JSON.stringify(serverDate.参数))
                this.result=serverDate.参数
              }

    })

    //注意:JSON.stringify(数据) 对象转字符串
            //JSON.parse(数据) 字符串转对象

## day0420

### 跳出来的小窗口1

 promptAction.showToast({
            message:'手机格式有误'
          })

### 跳出来的返回窗口，需要点确定与否，返回小窗口

router.showAlertBeforeBackPage({
            message:'确定返回？'
          })

## day0425

泛型？？？：zhuceshizhan实例model下的result.ts
回调函数？？？:zhuceshizhan实例下的utils下的request.ts
网络请求封装，使用：zhuceshizhan实例
品一下最近这个后端的内容，看到了123分钟？？？

### 泛型的优势：

将参数作为值传递：
class result<T=null>{
    state:string
    date:T
}
访问后端的URL:
后端的UrL的访问结果参数，serverdate是网址的访问结果，首先找出他的参数，在参数下的数组又可以分为好几个参数，所以要定义好两个类，利用泛型可以将多个类联系在一起

### 持久性的存储

### 需要记住短信倒计时特效的代码，必背

### 数据持久化：

放在app入口页面才可以数据持久化，其他@Entry都是自定义组件。

### 页面：zhuceshizhan中，以下内容都不能放在build里面，要放在build()同级

onPageShow
页面每次显示时触发一次，包括路由过程，应用进入前台等场景，仅@Entry装饰的自定义组件生效
onPageHide
页面每次隐藏时触发一次，包括路由过程，应用进入前后台等场景，仅@Entry装饰的自定义组件生效
onBackPress
当用户点击返回按钮时候触发，仅@Entry装饰的自定义组件生效

### 修改入口文件

在entryability下的Entryability.ts中的
windowStage.loadContent('pages/Index')
如果要修改的话，直接将上面的路径改了就是，这就是App入口文件，在这个地方运行，数据持久化。

### 组件

aboutToAppear 发送网络请求，跟onPageShow(){

}是一样的意思，同时存在，先调用aboutToAppear,再调用onPageShow
aboutToDisappear(){}，只有调用的是replaceUrl后才可以调用aboutToDisappear(){}，组件销毁，但是如果是pushUrl，就不会调用aboutToDisappear(){}。

## day0428

### 上下拉，上拉加载，见实例zhuceshizhan

List(){
    ForEach(){
        this.goods,()=>{
            ListItem(){
                布局
            }
        }
    }
    ListItem()判断到底否
}
.onScrollIndex((start,end)=>{
    `<!-- end表示当前列表最后一个数据的索引 -->`
})

注意：listItem只能写一个，如果要写多行内容，可以用Column或者Row装起来，另外，List()必须加width和height,不然不能滑动。

自定义组件不用放在ListItem也可以成功。

## day0503  zhuceshizhan

### 购物车删除  zhuceshizhan

### callback回调函数

传递函数，回头去调用，例如：forEach,拿到服务器函数等

### promise函数来代替callback函数，因为callback函数，括号太多了，冗杂。

鸿蒙中的Api指的是语法的意思
服务器中指的是Api接口，操作数据库的意思

<!-- const p=new Promise((resolve,reject)=>{

} ) -->

const p=new Promise((success,reject)=>{
    写服务器请求代码 也就是httpRequest...
    拿到服务器数据之前是调用callback 但是调用了之后就出现了回调地狱的问题
    现在把数据保存到Promise对象里面 不管成功与否 success(写成功的数据)，error(写失败的数据)=》这么一些数据就自动保存到了Promise对象中 也就是p中=》后期如何获得 通过.then 或者.catch方法来获取
} )
p
.then(data=>{
    `<!-- 也就是之前success传递的数据 -->`
})
.catch(err=>{
    `<!-- 也就是reject传递的数据 -->`
})
上面这个new Promise不用写，因为在鸿蒙中默认的就是new Promise()

### api语法，在服务器中才是api接口，不然在鸿蒙中就是语法,async和await语法

async和await的语法，见zhuceshizahn之Test3
这个是promise函数的升级版，后期实战都使用现在这个。
async放在定义函数的前面，async()=>{},await一般是放在要调用的函数前面，函数传参的这种形式前面，await就是不用写then,他会自动将.then里面的值显示出来。
async on动词功能名Api(){

}
on动词功能名Api=async()=>{

}
//有箭头函数在箭头函数前面写async,普通函数就在函数名前面加async,上面两个形式语法是一样的

### 节流防抖

1.写功能
2.用计时器将事件功能包起来
3.关键
定时器前面加判断
有定时器 return 节流
有定时器 clearTimeout()防抖
实例见zhuceshizhan实例中的Test4
节流：一段时间内，只允许你执行一次
防抖：一段时间内，可以重复随意执行，但是必须先取消上一次

### zhuceshizhan实例中的Test4为百度搜索实例

### 样式复用@Extend(Text)和 @Styles function iptStyle(){}，@Style可以放在组件内，build()同级，或者全局变量，@Extend()只能全局变量，详情见demo32的Index和Index2,@Extend传参，详情也是Index2中

### 样式复用之Index3，@Extend()的焦点获取和拾取：（类似于三目运算）

 .onFocus(()=>{//获取焦点事件，当获取焦点触发
          this.codeWidth=60
        })
.onBlur(()=>{//拾取焦点触发
          this.codeWidth=40
        })

### 多态 stateStyles():可以依据组件的内部状态的不同，快捷设置不用样式：demo32之index4

normal:正常态
pressed:按压态
focused:获焦态。
disabled:不可用态。

### 自定义构建函数

#### @Builder：可以组件内定义或者全局定义，详情见demo32之Index5

#### @Builder自定义函数的传参：demo32之Index6

#### @Builder自定义函数，尾随闭包，demo32之Index7:@BuilderParam传递UI，在struct xxx{}里面添加

## day0507

### 弹性布局Flex

#### 骰子的布局：zhuceshizhan之shaizibuju

#### 有错一定要注意加宽，没有宽就不会有效果

#### 实战：zhuceshizhan之shaizibuju,投骰子实例，用来实战学过的弹性盒子

#### 自定义拉伸：详情见zhuceshizhan之ceshi，flexGrow放大，flexShrink缩小

@Entry
@Component
struct Index{
  build(){
    // 放大：值越大，效果越明显
    // Flex(){
    //   Text('1').width(50).height(50).backgroundColor(Color.Red)
    //   Text('2').width(50).height(50).backgroundColor(Color.Green).flexGrow(2)
    //   Text('3').width(50).height(50).backgroundColor(Color.Blue).flexGrow(1)
    // }
    // 缩小：值越大，效果越明显
    Flex(){
      Text('1').width('50%').height(50).backgroundColor(Color.Red)
      Text('2').width('50%').height(50).backgroundColor(Color.Green).flexShrink(4)
      Text('3').width('50%').height(50).backgroundColor(Color.Blue).flexShrink(3)
    }
    .width('100%')
    .height(500)
    .backgroundColor('#000')
  }
}

### 层叠布局stack：详情见zhuceshizhan之cengdieStack

@Entry
@Component
struct Index{
  build(){
    Stack(){
      //后一元素覆盖前一元素

    Text('Text').fontColor('black').fontSize(50).width('80%').height(100).backgroundColor('blue')
      Button('Button')
    }
    .width('100%')
    .height(500)
    .backgroundColor(Color.Green)

  }
}

#### zIndex(cengdiebuju实例下)

默认zIndex(0),zIndex(n),n越大，表示层级越高，n越大的将覆盖前面n小的元素

#### offset(cengdiebuju实例下)

.offset({x:值1,y:值2})
用来设置元素的位置

#### 控制滚动的对象：Scroller,详情见demo32之Index0,点击向上按钮，滑到列表顶部

@Entry
@Component
struct Index{
  @State names:number[]=[1,2,3,4,5,6,7,8,9]
  @State isShow:boolean=false
  scroller:Scroller=new Scroller()
  //Scroller 鸿蒙里面内置的 控制滚动的对象
  build(){
    //1 定义数组，里面是1-9
    //2 视图循环展示
    //3 返回顶部Text 层叠布局
    //4 当滑动到第五个再显示 保存状态 判断

    Stack({alignContent:Alignment.BottomEnd//判断整体的布局是下结尾
    }){

    List({scroller:this.scroller}){
        ForEach(this.names,(item:number)=>{
          ListItem(){
            Text(String(item)).width('100%').height(200).backgroundColor("gray").margin({bottom:20})
          }

    })
      }
      .onScrollIndex((startIndex,endIndex)=>{
        this.isShow=endIndex>5
      })
      if(this.isShow){
        Text('↑').width(80).height(80).borderRadius(40).backgroundColor('#000').fontColor('#fff').fontSize(40).textAlign(TextAlign.Center)
          .stateStyles({
            pressed:{
              .backgroundColor('red')
            }
          })
          .onClick(()=>{
            this.scroller.scrollToIndex(0)
          })

    }

    }
  }
}

## day0508

### 线性布局Row()/Column()

backgroundColor(Color.Yellow)
backgroundColor('yellow')
backgroundColor('#000')

1.Row({space:30}){

}
//相当于Row()/Column肚子里面的每个内容相隔30个空间，这只包括大的，如果，肚子里面还有肚子，那么小肚子里面的内容不会相隔30，要单独设置（类似于margin）
2.Row(){

}.justifyContent(FlexAlign.Start)设置整体内容处于横向的开始，以下内容同理
/.justifyContent(FlexAlign.Center)横向中间
/.justifyContent(FlexAlign.End)横向结尾
/.justifyContent(FlexAlign.SpaceBetween)横向自动将内容分隔开
/.justifyContent(FlexAlign.SpaceAround)横向元素之间的距离比两侧大一倍
/.justifyContent(FlexAlign.SpaceEvenly)横向元素之间平均分配，跟上面对比

3.Row(){

}.alignItems(VerticalAlign.Bottom)设置为纵向的底部，交叉对齐方式

4.Text().width(100).height(100).alignSelf(ItemAlign.Center)
Text().width(100).height(100).alignSelf(ItemAlign.Start)
Text().width(100).height(100).alignSelf(ItemAlign.End)

5.Column(){

}.alignItems(HorizontalAlign.Center/Start/End)设置为横向的中间，开始，结尾

6.Column(){

}.justifyContent(FlexAlign.Start)
/.justifyContent(FlexAlign.Center)
/.justifyContent(FlexAlign.End)
/.justifyContent(FlexAlign.SpaceBetween)
/.justifyContent(FlexAlign.SpaceAround)
/.justifyContent(FlexAlign.SpaceEvenly)

7.自定义伸缩：
layoutWeight(n) 占剩余空间
Row()/Column（）的肚子里面的内容，假设一共有4个元素，如果所有内容都是layoutWeight(1),将自定义平分内容
只有一个是layoutWeight(1)，将占余剩下部分空间
有两个元素是layoutWeight(1)，其余没有，将先匹配无layoutWeight()的宽度，然后剩余空间平分，layoutWeight(n),指的是将内容按照n1,n2比例分开

8.弹性盒子Flex:可以用来代换Column/Row()
Flex({}){

}
默认主轴是水平方向的
Flex({direction:FlexDirection.Row}){

}
//内容水平方向排列
Flex({direction:FlexDirection.Column}){

}
//内容纵向方向排序

9.Flex({justifyContent:FlexAlign.Center}){

}
如果没有设置direction,默认为横向水平排列
表示里面的内容都整体放在水平方向的中间位置
就算一行写不完，也会水平排列
因此如果一行写不完，将自动将内容折行：
Flex({wrap:FlexWrap.Wrap}){}设置折行
Flex({wrap:FlexWrap.noWrap}){}设置不折行

Flex({alignItems:ItemAlign.Center/End/Start}){

}默认主轴是水平排列，那么aligItems这个表示设置他为纵向的中间，结尾，开始

### 栈格，匹配不同的手机型号，自定义伸缩

@Entry
@Component
struct Index{
  @State bgColor:Color[]=[Color.Red,Color.Black,Color.Blue,Color.Brown,Color.Green,Color.Orange]
  build(){
    GridRow(){
      ForEach(this.bgColor,(item:Color,i:number)=>{
        GridCol({
          span:{
            xs:12,//xs最小屏，每个元素占12个栈格，也就是一行一个,<200vp,相当于预览器600px
            sm:6, //小屏设备，每个元素占6个栈格 ,也就是一行两个，200-300vp，=>600-900px
            md:4,//中屏，每个元素占4个，也就是一行3个,300-400vp
            lg:2 //大屏，每个元素占2个，也就是一行6个,400-500vp
            //xl 特大 >500vp  xxl 超大 >500vp

    }
        }){
          Text(String(i)).width('100%').height(50).backgroundColor(item)
        }

    })

    }
  }
}

### 自定义尺寸范围：详情见demo32之GridRow实例

GriRow({
    gutter:{x:10,y:20},//设置栈格之间的间距
    breakPoints:{value:['200vp','300vp','400vp','500vp']}//自定义设置尺寸
}){
    ForEach(this.bgColor,(item:Color,i:number)=>{
        GridCol({
          span:{
            xs:12,//xs最小屏，每个元素占12个栈格，也就是一行一个,<200vp,相当于预览器600px
            sm:6, //小屏设备，每个元素占6个栈格 ,也就是一行两个，200-300vp，=>600-900px
            md:4,//中屏，每个元素占4个，也就是一行3个,300-400vp
            lg:2 //大屏，每个元素占2个，也就是一行6个,400-500vp
            //xl 特大 >500vp  xxl 超大 >500vp

    }
        }){
          Text(String(i)).width('100%').height(50).backgroundColor(item)
        }

    })
}

### 网格布局Grid 这是二维的，上面只是一维的，适合写九宫格，详情见demo32之Index10

@Entry
@Component
struct Index{
  @Styles styleItem(){
    .backgroundColor('red')
  }
  build(){
    Grid(){
      GridItem(){Text('a')}.styleItem()
      GridItem(){Text('b')}.styleItem()
      GridItem(){Text('c')}.styleItem()
      GridItem(){Text('d')}.styleItem()
      GridItem(){Text('e')}.styleItem()
      GridItem(){Text('f')}.styleItem()
      GridItem(){Text('g')}.styleItem()
    }
    .width('100%')
    .height(600)
    .rowsGap(10)//行与行之间的距离为10
    .columnsGap(20)//列与列之间为20
    .backgroundColor('#ccc')
    .rowsTemplate('1fr 2fr 1fr')//三行,表示的是相对位置1fr
    .columnsTemplate('1fr 2fr 1fr')//三列
  }
}
  基本格式：
  Grid(){
    GridItem(){内容1}
    GridItem(){内容2}
  }
  .rowsGap(n1)
  .columnsGap(20)
  .rowsTemplate('1fr 2fr 1fr')
  .columnsTemplate('1fr 2fr 1fr')

### 网格布局实例demo32之Index10和jisuanji实例

  @Entry
@Component
struct Index{
  @Styles styleItem(){
    .backgroundColor('red')
  }
  build(){
    Grid(){
      GridItem(){Text('a')}.styleItem()
      .columnStart(1)
      .columnEnd(2)
      GridItem(){Text('b')}.styleItem()
      .rowStart(1)
      .rowEnd(2)
      GridItem(){Text('c')}.styleItem()
      .rowStart(1)
      .rowEnd(2)
      GridItem(){Text('d')}.styleItem()
      GridItem(){Text('e')}.styleItem()
      GridItem(){Text('f')}.styleItem()
      GridItem(){Text('g')}.styleItem()
    }
    .width('100%')
    .height(600)
    .rowsGap(10)
    .columnsGap(20)
    .backgroundColor('#ccc')
    .rowsTemplate('1fr 1fr 1fr 1fr')//四行，设置行数以及内容的比例
    .columnsTemplate('1fr 1fr 1fr')//三列
  }
}
注意：GridItem(){}
.columnStart(1)
.columnEnd(2)
从他开始，列向下再走一个，1，2，3表示的是从他走三列

### 疑问：offset的位置是咋看的？以及办公页面代码的书写？

### return 用来终止方法的执行

### 计时器的写法：固定写法：clearInterval写在setInterval里面，if循环只能判断一次，不能回调继续判断

 this.t=setInterval(()=>{
              if(this.time<=1){
                clearInterval(this.t)
                this.context='获取验证码'

    this.time=10
                this.disabled=false
                return
                //return 用来终止函数，即终止onclick
              }
              this.time--
              this.context=`剩余${this.time}s`

    },1000)

### 快捷键的运用：

目录下不用点击多个分框，crl+n然后在搜索下输入Art，回车就可以新建Artics语言
设置下快捷键然后输入搜索，设置键盘添加快捷键，设置为esc按键，按esc按钮，就可以实现搜索，你可以搜索你需要的文件夹名字，就可以直接跳转到那个文件下了。不用到处找目录下的文件，方便，快捷。

### select 下拉菜单的属性：

详情可以见鸿蒙官方文档下查看

### Tabbar 和NavBar:

详情可以见鸿蒙官方文档下查看
### 注意：如果不停的设置宽度啊，高度，甚至Justifi。。。都无法将内容变化，要么没有设置宽高，要么就是里面的内容的宽度和高度设置得不合理，可以使用layoutWeight(1)，将整个页面都用完，用不完得话就会出这种错
### 高度设置为100%的意思是将内容填充，不会将原本的内容给挤下去，跟layoutweight(1)作用差不多，反正可以试试，用于将内容顶上去。
### 注意：list可加可不加宽度，高度等，视情况而定
### 注意：margin可以将高度变化
### 申请网络权限：在"module":下面加上后面这一句（module.json5中）
 "requestPermissions": [
      {
        "name": "ohos.permission.INTERNET"
      }
    ],
### 鸿蒙中的接口文档中：state===200和state===201的区别：

state===200 表示接口请求成功，状态码为200。这意味着服务器成功返回请求的数据。
state===201 表示接口请求成功，但状态码为201。状态码201通常表示资源已经被创建，比如在进行 POST 请求时创建新资源成功。
### 各种快捷键是啥？？？
### 请假申请提交显示网络繁忙，后面再试试，看能不能成功？？？
### 页面跳转的传参
在router.pushUrl({
  url:"",
  params:{
    传参的内容
  }
})
在跳转后的页面里面写出下面的数据：
 const data= router.getParams()
 ### 长度为5，如果没有这么长，将默认在前面加上你需要的值进行填充：语法如下：
 String.padStart(maxLength: number, fillString?: string): string
 ### 长度为5，如果没有这么长，将默认在后面加上你需要的值进行填充：语法如下：
 String.padEnd(maxLength: number, fillString?: string): string
 ### 常见错误：Foreach
 在foreach循环中，利用自定义函数@Builder xxx(){}写循环，在循环外面不要加那么多的Column或者Row,否则会出错，显示不出结果，但是如果不是在自定义函数里面写循环，循环外面可以加Column或Row,甚至在某些内容下，有些可以用Foreach，有些能用this.arr.foreach((item:xxx)=>{
  内容
 })
 视情况而定。Foreach是内置的，而后面那个不是其自带的内置的函数。注意代码的冗余情况，不要太冗余，否则不能出结果。
 ### list里面可以加自定义函数这个可以不用加listItem,其他的需要加ListItem.
 ## day0526
 ### 后台数据管理
  #### 动态页面出现形式:https://animate.style/,详情见此文件夹下的登录.html实例
  ####  cursor: pointer;  一种样式：/* 单独记 ⿏标有种⼿势感觉 */
  #### 网页中表格的写法：详情见此文件夹下的网页中的表格写法.html,代码如下：

  <!DOCTYPE html>
<html>
<head>
    <title>HTML 表格示例</title>
</head>
<body>
    <table border="1">
        <tr>
            <td>行1列1</td>
            <td>行1列2</td>
            <td>行1列3</td>
        </tr>
        <tr>
            <td>行2列1</td>
            <td>行2列2</td>
            <td>行2列3</td>
        </tr>
    </table>
</body>
</html>

### css基础补充，当非一行标签设置长宽高：需要在后面加上以下代码：
 display: inline-block;
        /* css中有非独占一行的标签不能单纯设置宽度，高度，需要加上上面这一行代码 */
<span>内容<span>这个是非独占一行标签，是空标签，也是行标签，不能独占一行，在设置长宽高的时候需要加上上面的代码
<div>内容<div>这个是列标签，独占一行的，就不用加上面的代码

## 注意复习的时候看一下每一节的课程pdf,内容很有用。
### 登录.html 审批.html
## day0530
### 索引签名：[key:string]=xxx
'技术部'=类型
给所有标签统一添加类型
### @state 页面响应
### 所有的访问权限的内容都不太行，到时候问问老师？？？有哪些问题见我发给‘以爱之名’的聊天记录。
### 多任务进程，详情见实例WantTest，在视频Stage模型的详情的那几节内容，讲了修改图标和名字，同时如何设置多任务进程
### 讲了修改图标和名字：详情见WorK实例，在视频Stage模型的详情的那几节内容，讲了修改图标和名字，同时如何设置多任务进程：利用Want实现多实例
在app.json5中修改的是设置里面的软件的图标，而在module.json5中修改的则是桌面上的图标和名字，如果名字为中文名字，要在Zh-C中修改label。
### 如何在Want中传参？？？下一讲讲
## 总结：多任务，stage模型
主要讲了应用模型，修改自己的图标，App名字，包括设置的图标和名字，和桌面的图标和App名字
启动模式：单实例组件，多实例组件，指定实例组件：多任务
生命周期的顺序如下：
onCreate===>onWindowStageCreate====>onforground====>onbackground====>onWindowStageDestroy====>onDestroy
第一个相当于aboutToappear,用来创建新的数据，一般用来响应式等新的数据
最后一个相当于aboutTodisappear，用来销毁组件
onforground相当于onPageShow，与aboutToappear相比，这个一般用来响应已经有的数据
onbackground相当于onPageHide
## day0605
### h5新增API（企业级面试）
(1) ⾳视频audio、video标签 
(2) 语义化标签article、footer、header、nav、section等
(3) 表单控件date、time、color、emial、url、search等
(4) 新增图形绘制canvas标签
(5) H5存储localStorage、sessionStorage
(6) 新的技术webworker, websocket, Geolocation;
(7) DNS预获取、FormData、FileReader、全屏API（Fullscreen API）
等等


 ### js基础巩固
 // let obj=111
// function fn(n){
//     n=10,
//     console.log(n) 输出10
// }
// fn(obj)
// console.log(obj) 输出111

let obj={name:'jjw'}
function fn(n){
    n.name='wangwang',
    console.log(n.name) 输出wangwang
}
fn(obj)
console.log(obj.name)   输出wangwang


//
基本数据类型按值传递，而对象类型是按引用传递，也就是第一个function，不会修改原数据的值，但是第二个function传的是对象，会修改原来的值。
### css属性汇总
行标签，不能设置长宽高，span标签，需要加上display:inline-block 这个表示这个所有行标签可以设宽高，且所有的span标签连在一起，成为一行。 
父标签设置弹性盒子： display: flex;那么在子节点中使用flex:1就可以占余剩余空间，与鸿蒙语法不同。
### 表格 table
 <table border="1" cellpadding="20" cellspacing="0">
        <tr>
            <th>
                biaotou
            </th>
        </tr>
        <tr>
            <td>内容</td>
        </tr>

    </table>

## day0708
### overflow语法：
overflow:hidden ====>溢出内容隐藏
overflow:visible====>溢出元素正常显示
overflow:auto====>当内容溢出时会在溢出方向自动生成滚动条
scroll则是无论内容是否溢出都在元素指定方向生成滚动条

### hover语法：
img:hover {}
用来表示鼠标悬停的情况
### transition:all .3s语法
用来定义元素在状态变化时的过渡时的过渡效果，表示这些变化在3秒内平滑过渡
### transform:scale(1,3)语法
表示将元素沿着水平方向保持原来大小，而垂直方向放大到原来的3倍。
